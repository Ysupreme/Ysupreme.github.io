<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/maomi-apple.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/maomi32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/maomi16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="关于java的一些基础知识回顾，包括基本概念，数据类型，关于面向对象的一些知识。参考了技术栈文章https:&#x2F;&#x2F;github.com&#x2F;frank-lam&#x2F;fullstack-tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="http://yoursite.com/2021/06/10/java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Ysupreme">
<meta property="og:description" content="关于java的一些基础知识回顾，包括基本概念，数据类型，关于面向对象的一些知识。参考了技术栈文章https:&#x2F;&#x2F;github.com&#x2F;frank-lam&#x2F;fullstack-tutorial">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-10T05:55:35.000Z">
<meta property="article:modified_time" content="2022-03-11T10:41:39.321Z">
<meta property="article:author" content="黄勇">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/06/10/java%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java基础 | Ysupreme</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ysupreme</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">黄勇的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/10/java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_inhuda.JPG">
      <meta itemprop="name" content="黄勇">
      <meta itemprop="description" content="放他三千裘马去，不寄俗生。唯贪我三枕黄粱梦。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ysupreme">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-10 13:55:35" itemprop="dateCreated datePublished" datetime="2021-06-10T13:55:35+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-11 18:41:39" itemprop="dateModified" datetime="2022-03-11T18:41:39+08:00">2022-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 分钟</span>
            </span>
            <div class="post-description">关于java的一些基础知识回顾，包括基本概念，数据类型，关于面向对象的一些知识。参考了技术栈文章https://github.com/frank-lam/fullstack-tutorial</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h1><h2 id="1-初始化顺序"><a href="#1-初始化顺序" class="headerlink" title="1.初始化顺序"></a>1.初始化顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态对象&gt;非静态</span><br><span class="line"></span><br><span class="line">父类先于子类</span><br><span class="line"></span><br><span class="line">成员变量按照定义的顺序初始化</span><br></pre></td></tr></table></figure>



<h2 id="2-和c-区别"><a href="#2-和c-区别" class="headerlink" title="2.和c++区别"></a>2.和c++区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.纯粹面向对象</span><br><span class="line">2.没有指针,它的引用可以理解为安全指针</span><br><span class="line">3.垃圾自动回收机制, C++ 需要手动回收</span><br><span class="line">4.不支持操作符重载</span><br><span class="line">5.通过jvm实现跨平台特性</span><br><span class="line">6.不支持多重继承</span><br><span class="line">7.内置了线程支持，而c++需要第三方库</span><br><span class="line">8.goto是保留字，不可以用</span><br><span class="line">9.不支持条件编译</span><br></pre></td></tr></table></figure>

<p>ps:条件编译笔记</p>
<p><a href="http://m.biancheng.net/c/ifdef/?ivk_sa=1024320u" target="_blank" rel="noopener">http://m.biancheng.net/c/ifdef/?ivk_sa=1024320u</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.条件编译的好处</span><br><span class="line">	1）编译器效率</span><br><span class="line">	2）防止头文件中的全局变量，多次编译，造作重复定义错误</span><br><span class="line">2.#ifndef与#ifdef区别</span><br><span class="line">3.#if	#endif	#elif	#else</span><br></pre></td></tr></table></figure>



<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h2><p>反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）</p>
<p>程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p><font color=red>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</font></p>
<p>　　</p>
<p>动态加载资源</p>
<h2 id="4-注解——annotation"><a href="#4-注解——annotation" class="headerlink" title="4.注解——annotation"></a>4.注解——annotation</h2><p>自定义注解类编写规则</p>
<ol>
<li>Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.</li>
<li>参数成员只能用 public 或默认(default)这两个访问权修饰</li>
<li>参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组</li>
<li>要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li>
<li>注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</li>
</ol>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h2><p>jdk5之后引入</p>
<p>1）泛型方法：在调用时可以接收不同类型的参数</p>
<p>​    有一个类型参数，如    public <E> void printMsg(E e){}</p>
<p>​    类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）</p>
<p>2)泛型类</p>
<p>3）类型通配符    例如 <strong>List&lt;?&gt;</strong> 在逻辑上是<strong>List<String>,List<Integer></strong> 等所有List&lt;具体类型实参&gt;的父类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型通配符上限，形如：List&lt;? extends Number&gt;表示接收Number及其下层类型</span><br><span class="line">类型通配符下限，形如：List&lt;? super Number&gt;表示类型只能接受Number及其三层父类类型</span><br></pre></td></tr></table></figure>



<h2 id="6-字符编码与字节"><a href="#6-字符编码与字节" class="headerlink" title="6.字符编码与字节"></a>6.字符编码与字节</h2><table>
<thead>
<tr>
<th>ANSI 字符串</th>
<th>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 <strong>ANSI 字符串</strong>或者<strong>多字节字符串</strong>。</th>
</tr>
</thead>
<tbody><tr>
<td>UNICODE 字符串</td>
<td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串</strong>或者<strong>宽字节字符串</strong>。</td>
</tr>
</tbody></table>
<p>不同编码里，字符和字节的对应关系不同</p>
<table>
<thead>
<tr>
<th>类型</th>
<th><strong>概念描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。</td>
</tr>
<tr>
<td>UTF-8</td>
<td>一个英文字符等于一个字节，一个中文（含繁体）等于三个字节</td>
</tr>
<tr>
<td>Unicode</td>
<td>一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占 1 个字节的大小，中文句号“。”占 2 个字节的大小。</td>
</tr>
<tr>
<td>UTF-16</td>
<td>一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode扩展区的一些汉字存储需要4个字节）</td>
</tr>
<tr>
<td>UTF-32</td>
<td>世界上任何字符的存储都需要 4 个字节</td>
</tr>
</tbody></table>
<h2 id="7-访问修饰符"><a href="#7-访问修饰符" class="headerlink" title="7.访问修饰符"></a>7.访问修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一个包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default(默认)</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><font color=red>Java 中，外部类的修饰符只能是 public 或默认</font>，类的成员（包括内部类）的修饰符可以是以上四种</p>
<h2 id="8-浅拷贝深拷贝"><a href="#8-浅拷贝深拷贝" class="headerlink" title="8.浅拷贝深拷贝"></a>8.浅拷贝深拷贝</h2><h2 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9.lambda表达式"></a>9.lambda表达式</h2><p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口</p>
<p>免去了使用匿名表达式的麻烦（函数化编程能力</p>
<p>2）变量作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</span><br><span class="line"></span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line"> </span><br><span class="line">   final static String salutation &#x3D; &quot;Hello! &quot;;</span><br><span class="line">   </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      GreetingService greetService1 &#x3D; message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(&quot;Runoob&quot;);&#x2F;&#x2F;假设已定义该方法</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   interface GreetingService &#123;</span><br><span class="line">      void sayMessage(String message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String first &#x3D; &quot;&quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译会出错</span><br><span class="line">Comparator&lt;String&gt; comparator &#x3D; (first, second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure>

<h2 id="10-字符串常量池"><a href="#10-字符串常量池" class="headerlink" title="10.字符串常量池"></a>10.字符串常量池</h2><p>1）创建字符串</p>
<p>字面量形式，如 <code>String str = &quot;abc&quot;;</code></p>
<p>标准的构造对象的方法，如 <code>String str = new String(&quot;abc&quot;);</code></p>
<p><font color=red>这两种实现其实存在着一些性能和内存占用的差别。这一切都是源于 JVM 为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被称为字符串常量池或者字符串字面量池。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">        String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以上两个局部变量都存在了常量池中</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; new出来的对象不会放到常量池中,内存地址是不同的</span><br><span class="line">        String s3 &#x3D; new String();</span><br><span class="line">        String s4 &#x3D; new String();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">     	* 字符串的比较不可以使用双等号,这样会比较内存地址</span><br><span class="line">     	* 字符串比较应当用equals,可见String重写了equals</span><br><span class="line">     	*&#x2F;</span><br><span class="line">        System.out.println(s3 &#x3D;&#x3D; s4); &#x2F;&#x2F; false</span><br><span class="line">        System.out.println(s3.equals(s4)); &#x2F;&#x2F; true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:==与equals()区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;比较的是内存地址（引用）</span><br><span class="line"></span><br><span class="line">equals()比较的是对应的值</span><br></pre></td></tr></table></figure>



<p>11.解释型语言与编译型语言</p>
<p>　　将高级语言翻译成计算机语言有编译，解释两种方式。两种方式只是翻译的时间不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">编译语言：</span><br><span class="line">直接转换为处理器可以执行的机器代码。</span><br><span class="line">	1）结果，它们会比解释语言更快更高效地执行</span><br><span class="line">	2）每次需要进行更改时，你都需要重新编译（缺点：在测试之前完成整个编译步骤需要额外的时间</span><br><span class="line">	3）生成的二进制代码对平台的依赖性，可移植性差</span><br><span class="line"></span><br><span class="line">解释型语言：</span><br><span class="line">由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</span><br><span class="line">	1）解释型语言更加灵活，并且通常具有诸如动态键入和程序较小的特点。</span><br><span class="line">	2）另外，由于解释器自己执行源程序代码，因此代码本身相对于平台是独立的。</span><br></pre></td></tr></table></figure>

<h1 id="二-java面向对象"><a href="#二-java面向对象" class="headerlink" title="二.java面向对象"></a>二.java面向对象</h1><h2 id="1-面向对象的四个基本特性"><a href="#1-面向对象的四个基本特性" class="headerlink" title="1.面向对象的四个基本特性"></a>1.面向对象的四个基本特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象</span><br><span class="line">封装：我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作		的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</span><br><span class="line">继承：继承是从已有类得到继承信息创建新类的过程</span><br><span class="line">多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。</span><br></pre></td></tr></table></figure>

<p>1）多态的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法重载(overload)</span><br><span class="line"></span><br><span class="line">方法重写(override)</span><br></pre></td></tr></table></figure>

<p>2)<strong>面相对象开发方式优点（B65）</strong></p>
<p>较高的<strong>开发效率</strong>：可以把事物进行抽象，映射为开发的对象。</p>
<p>保证软件的<strong>鲁棒性</strong>：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。</p>
<p>保证软件的<strong>高可维护性</strong>：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好</p>
<h2 id="2-什么是重载、重写"><a href="#2-什么是重载、重写" class="headerlink" title="2.什么是重载、重写"></a>2.什么是重载、重写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.重载</span><br><span class="line">	发生在一个类中，同名的方法有不同的参数列表（参数类型不同、参数个数不同，或者二者都不同）</span><br><span class="line">	1)被重载的方法必须改变参数列表(参数个数或类型不一样)；</span><br><span class="line">	2)被重载的方法可以改变返回类型；</span><br><span class="line">	3)被重载的方法可以改变访问修饰符；</span><br><span class="line">	4）被重载的方法可以声明新的或更广的检查异常</span><br><span class="line">	</span><br><span class="line">2.重写</span><br><span class="line">	发生在子类与父类之间</span><br><span class="line">	1）参数列表与被重写方法的参数列表必须完全相同。</span><br><span class="line">	2）返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java7及以后</span><br><span class="line">	3）访问权限不能比父类中被重写的方法的访问权限更低</span><br><span class="line">	4）声明为 final 的方法不能被重写。声明为 static 的方法不能被重写，但是能够被再次声明。</span><br><span class="line">	5）能不能重写和访问修饰符有关</span><br><span class="line">	6）构造方法不能被重写</span><br><span class="line">	7）不能比父类被重写方法声明更多的异常（里氏代换原则）</span><br></pre></td></tr></table></figure>

<p><font color=red>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</font></p>
<p>菜鸟教程：<a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-override-overload.html</a></p>
<h2 id="3-面向对象与面向过程区别"><a href="#3-面向对象与面向过程区别" class="headerlink" title="3.面向对象与面向过程区别"></a>3.面向对象与面向过程区别</h2><p>4.面向对象开发六个基本原则</p>
<p>参考《设计模式之禅》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.单一职责（Single Responsibility Principle 简称 SRP）：一个类应该仅有一个引起它变化的原因。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。</span><br><span class="line"></span><br><span class="line">2。里氏替换（Liskov Substitution Principle 简称 LSP）：任何时候子类型能够替换掉它们的父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。</span><br><span class="line"></span><br><span class="line">3.依赖倒置（Dependence Inversion Principle 简称 DIP）：要依赖于抽象，不要依赖于具体类。要做到依赖倒置，应该做到：①高层模块不应该依赖底层模块，二者都应该依赖于抽象；②抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</span><br><span class="line"></span><br><span class="line">4.接口隔离（Interface Segregation Principle 简称 ISP）：不应该强迫客户依赖于他们不用的方法 。接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。</span><br><span class="line"></span><br><span class="line">5.最少知识原则（Least Knowledge Principle 简称 LKP）：只和你的朋友谈话。迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</span><br><span class="line"></span><br><span class="line">6.开闭原则（Open Closed Principle 简称 OCP）：软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。</span><br></pre></td></tr></table></figure>



<h2 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">成员内部类：</span><br><span class="line">	无限制的访问外围类的所有成员属性和方法，尽管是private的，外围类要访问内部类的成员	属性和方法则需要通过内部类实例来访问。</span><br><span class="line">	不能存在static方法, 但是可以存在static域, 前提是需要使用final关键字进行修饰.</span><br><span class="line">	成员</span><br><span class="line">局部内部类：</span><br><span class="line">	它是嵌套在方法和作用域内的，</span><br><span class="line">匿名内部类：</span><br><span class="line">	匿名内部类也就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通	 常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</span><br><span class="line">	最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是继承 		Runnable 接口</span><br><span class="line">静态内部类</span><br><span class="line">	它的创建是不需要依赖于外围类的。</span><br><span class="line">	它不能使用任何外围类的非 static 成员变量和方法</span><br></pre></td></tr></table></figure>



<h2 id="6-组合、继承和代理的区别"><a href="#6-组合、继承和代理的区别" class="headerlink" title="6.组合、继承和代理的区别"></a>6.组合、继承和代理的区别</h2><h2 id="7-构造函数"><a href="#7-构造函数" class="headerlink" title="7.构造函数"></a>7.构造函数</h2><p>不需要返回值类型（和void不是一个概念）</p>
<p>且构造函数的名称与所在的类名完全一致，其余的与函数的特性相同，可以带有参数列表，可以存在函数的重载现象。</p>
<h2 id="8-向上造型和向下造型"><a href="#8-向上造型和向下造型" class="headerlink" title="8.向上造型和向下造型"></a>8.向上造型和向下造型</h2><p>​    接口回调：可以把使用实现了某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法</p>
<p>​    上转型对象：</p>
<p>比如当子类创建一个对象，并把这个对象的引用放到父类对象中时。对象的上转型对象的实体是子类负责创建的，但上转型对象会失去原对象的一些属性 和 功能（上转型对象相当于子类对象的一个“简化”对象）</p>
<h1 id="三-关键字"><a href="#三-关键字" class="headerlink" title="三.关键字"></a>三.关键字</h1><h2 id="1-final与static的区别"><a href="#1-final与static的区别" class="headerlink" title="1.final与static的区别"></a>1.final与static的区别</h2><p>final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.数据</span><br><span class="line">	为常量</span><br><span class="line">	对于基本类型，final使得数值不变</span><br><span class="line">	对于引用类型，final使得引用不变（但是引用的对象本身是可以修改的）</span><br><span class="line">2.方法</span><br><span class="line">	那么该方法不能被子类覆盖</span><br><span class="line">	（private方法被隐式地指定为final）</span><br><span class="line">3.类</span><br><span class="line">	该类不能被继承(比如String)</span><br></pre></td></tr></table></figure>

<p>static</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.静态变量</span><br><span class="line">	在内存中只有一份，只在类初始化时赋值一次</span><br><span class="line">	（ps：实例变量，每个类在创建一个对象时就会实例化它的实例变量</span><br><span class="line">	（ps：不能在成员函数内部定义static变量</span><br><span class="line">2.静态方法</span><br><span class="line">	必须有实现</span><br><span class="line">3.静态语句块</span><br><span class="line">	在类初始化的时候运行一次（效率？？？</span><br><span class="line">4.静态内部类</span><br><span class="line">	内部类的一种，不依赖于外部类，不能访问外部类的非静态变量和方法</span><br><span class="line">5.静态导包</span><br><span class="line">	import static com.xxx.ClassName.*</span><br><span class="line">6.变量赋值顺序</span><br><span class="line">	静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行</span><br><span class="line">	静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</span><br><span class="line">	（再就是构造函数</span><br><span class="line">	（继承情况下</span><br></pre></td></tr></table></figure>



<h2 id="2-break、continue、return"><a href="#2-break、continue、return" class="headerlink" title="2.break、continue、return"></a>2.break、continue、return</h2><p>break:跳出当前循环</p>
<p>continue：终止当前循环，继续往下根据循环条件执行循环</p>
<p>return：可以不带参数返回，主要目的就是中断函数执行，返回函数调用出</p>
<h2 id="3-final、finally和finalize区别"><a href="#3-final、finally和finalize区别" class="headerlink" title="3.final、finally和finalize区别"></a>3.final、finally和finalize区别</h2><p>1）final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承。</p>
<p>2）finally：用于异常处理，只能用在 try/catch 语句中</p>
<p><font color=red>3）画重点：finallly代码块不会被执行的两种情况</font></p>
<p>3.1）情况1：当代码在try语句之前结束运行时，finally代码块不会被执行</p>
<p>3.2）情况2：当执行try语句块的线程终止时，finally代码块不会被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可能是try语句块里执行了System.exit()</span><br><span class="line">或者该线程被中断被kill</span><br></pre></td></tr></table></figure>

<p><font color=red>4）try_catch_finally和return的执行顺序问题</font></p>
<p>​    <strong>finally块的执行时间点在try和catch中return语句的表达式值计算之后返回之前。</strong> 不论try和catch代码块中有没有return语句，执行顺序都是先计算try或catch中return语句的表达式的值并暂存，<strong>然后执行finally代码块</strong>。若finally代码块中无return，则返回之前try或catch中暂存的return语句的表达式的值；若finally代码块中有return，则直接就地返回。</p>
<p>5)finalize()方法</p>
<p>​    finalize() 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 finalize() 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何最后的救赎</span><br></pre></td></tr></table></figure>

<p>该方法没设么鸟用</p>
<h2 id="4-assert有什么作用"><a href="#4-assert有什么作用" class="headerlink" title="4.assert有什么作用"></a>4.assert有什么作用</h2><p>​    一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制</p>
<p>​    一般来说，assertion 用于保证程序最基本、关键的正确性。<strong>assertion 检查通常在开发和测试时开启</strong>。为了提高性能，<strong>在软件发布后，assertion 检查通常是关闭的</strong>。下面简单介绍一下 Java 中 assertion 的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    assert a == b; <span class="comment">//需显示开启，默认为不开启状态 </span></span><br><span class="line">    assert a == b : <span class="string">"执行失败！"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"1234"</span>);c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的断言方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5.volatile"></a>5.volatile</h2><p>类型修饰符：被设计用来修饰被不同线程访问和修改的变量</p>
<p><font color=red>在使用 volatile 修饰成员变量后，所有线程在任何时间所看到变量的值都是相同的。此外，使用 volatile 会组织编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用 volatile 就尽量不要使用 volatile。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每次访问变量时，总是获取主内存的最新值</span><br><span class="line">每次修改变量后，立刻写回到主内存中</span><br></pre></td></tr></table></figure>



<h2 id="6-instanceof"><a href="#6-instanceof" class="headerlink" title="6.instanceof"></a>6.instanceof</h2><p>二元操作符，测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p>
<p><font color=red>不是运算符</font></p>
<h2 id="7-strictfp"><a href="#7-strictfp" class="headerlink" title="7.strictfp"></a>7.strictfp</h2><p>​    可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的 float 和 double 表达式都严格遵守 FP-strict 的限制,符合 IEEE-754 规范。当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示。</p>
<p>​    如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.</p>
<h2 id="8-transient"><a href="#8-transient" class="headerlink" title="8.transient"></a>8.transient</h2><p>这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<p><font color=red>Java 的 transient 关键字为我们提供了便利，你只需要实现 Serilizable 接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</font></p>
<h2 id="9-native"><a href="#9-native" class="headerlink" title="9.native"></a>9.native</h2><p>​    Java 平台有个用户和本地 C 代码进行互操作的 API，称为 Java Native Interface (Java本地接口)。</p>
<h1 id="四-基本数据类型与运算"><a href="#四-基本数据类型与运算" class="headerlink" title="四.基本数据类型与运算"></a>四.基本数据类型与运算</h1><h2 id="1-Java的基本数据类型和引用类型，自动装箱和拆箱"><a href="#1-Java的基本数据类型和引用类型，自动装箱和拆箱" class="headerlink" title="1.Java的基本数据类型和引用类型，自动装箱和拆箱"></a>1.Java的基本数据类型和引用类型，自动装箱和拆箱</h2><table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>取值范围</th>
<th>默认值</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数型</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>最大存储数据量是 255，最小 -27，最大 27-1， [-128~127]</td>
<td>(byte) 0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>最大数据存储量是 65536，[-215,215-1]， [-32768,32767]，±3万</td>
<td>(short) 0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>最大数据存储容量是 231-1， [-231,231-1]，±21亿，[ -2147483648, 2147483647]</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>最大数据存储容量是 264-1， [-263,263-1]， ±922亿亿（±（922+16个零））</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td><strong>浮点型</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>数据范围在 3.4e-45~1.4e38，直接赋值时必须在数字后加上 f 或 F</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>数据范围在 4.9e-324~1.8e308，赋值时可以加 d 或 D 也可以不加</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td><strong>布尔型</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>true / flase</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td><strong>字符型</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>存储 Unicode 码，用单引号赋值</td>
<td>‘\u0000’ (null)</td>
<td>Character</td>
</tr>
</tbody></table>
<p>2）引用类型：数组、类、接口</p>
<p>3）自动装箱拆箱</p>
<p>基本数据类型和它对应的封装类型之间可以相互转换。自动拆装箱是 <code>jdk5.0</code> 提供的新特特性，它可以自动实现类型的转换</p>
<p>装箱<strong>：从</strong>基本数据类型<strong>到</strong>封装类型叫做装箱</p>
<p>拆箱<strong>：从</strong>封装类型<strong>到</strong>基本数据类型叫拆箱</p>
<h2 id="2-ValueOf缓存池"><a href="#2-ValueOf缓存池" class="headerlink" title="2.ValueOf缓存池"></a>2.ValueOf缓存池</h2><h2 id="3-i-与-i"><a href="#3-i-与-i" class="headerlink" title="3.i++与++i"></a>3.i++与++i</h2><p>1）<strong>i++ 的操作分三步</strong></p>
<ol>
<li>栈中取出 i</li>
<li>i 自增 1</li>
<li>将 i 存到栈</li>
</ol>
<p>三个阶段：内存到寄存器，寄存器自增，写回内存（这三个阶段中间都可以被中断分离开）</p>
<p>所以 i++ 不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致 i 的值不正确自增</p>
<p>2）原子性：指的是一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断</p>
<p>3）jvm三大特性：原子性、有序性、可见性</p>
<h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4.位运算符"></a>4.位运算符</h2><p>&amp;    |    ~    ^    &gt;&gt;    &lt;&lt;    &gt;&gt;&gt;(无符号右移)</p>
<h2 id="5-原码、反码、补码"><a href="#5-原码、反码、补码" class="headerlink" title="5.原码、反码、补码"></a>5.原码、反码、补码</h2><p>1）机器数：一个数在计算机中的二进制表示形式（带符号，1：负数，0：正数）</p>
<p>2）真值：因为第一位是符号位，所以机器数的形式值就不等于真正的数值</p>
<p>3）原码</p>
<p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是 8 位二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　[+1]原 &#x3D; 0000 0001</span><br><span class="line"></span><br><span class="line">　　[-1]原 &#x3D; 1000 0001</span><br><span class="line"></span><br><span class="line">　　第一位是符号位。因为第一位是符号位，所以 8 位二进制数的取值范围就是：[1111 1111 , 0111 1111]，即：[-127 , 127]</span><br></pre></td></tr></table></figure>

<p>4）反码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正数的反码：是其本身；</span><br><span class="line">负数的反码：是在其原码的基础上，符号位不变，其余各个位取反</span><br></pre></td></tr></table></figure>

<p>5）补码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正数的补码是：本身</span><br><span class="line">负数的补码是：反码的基础上+1</span><br><span class="line">[+1] &#x3D; [0000 0001]原 &#x3D; [0000 0001]反 &#x3D; [0000 0001]补</span><br><span class="line"></span><br><span class="line">[-1] &#x3D; [1000 0001]原 &#x3D; [1111 1110]反 &#x3D; [1111 1111]补</span><br></pre></td></tr></table></figure>



<h2 id="6-不用额外变量交换两个整数的值"><a href="#6-不用额外变量交换两个整数的值" class="headerlink" title="6.不用额外变量交换两个整数的值"></a>6.不用额外变量交换两个整数的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; a^b</span><br><span class="line">b &#x3D; a^b</span><br><span class="line">a &#x3D; a^b</span><br></pre></td></tr></table></figure>

<h2 id="7-不使用算术运算符实现两整数相加"><a href="#7-不使用算术运算符实现两整数相加" class="headerlink" title="7.不使用算术运算符实现两整数相加"></a>7.不使用算术运算符实现两整数相加</h2><h2 id="8-amp-和-amp-amp-的区别，-和-的区别"><a href="#8-amp-和-amp-amp-的区别，-和-的区别" class="headerlink" title="8.&amp;和&amp;&amp;的区别，||和|的区别"></a>8.&amp;和&amp;&amp;的区别，||和|的区别</h2><p>&amp;&amp;和||是逻辑运算符，|和&amp;是位运算符</p>
<p> &amp; 和 &amp;&amp; 在判断语句中都可以实现“和”这个功能，不过区别在于 &amp; 两边都运算，而 &amp;&amp; 先算 &amp;&amp; 左侧，若左侧为 false 那么右侧就不运算了。</p>
<p>因此从效率上来说，判断语句中推荐使用 &amp;&amp;（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？）</p>
<h1 id="五-字符串与数组"><a href="#五-字符串与数组" class="headerlink" title="五.字符串与数组"></a>五.字符串与数组</h1><p>1.String与StringBuffer、StringBuilder区别和联系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.三者都是final类，不可以被继承</span><br><span class="line">2.String长度不可变，其他两个可变</span><br><span class="line">3.StringBuffer是线程安全的，StringBuilder不是线程安全的，StringBuffer与StringBuilder相比加上了synchronized修饰</span><br><span class="line">4.因为第三点，StringBuilder比StringBuffer拥有更好的性能</span><br><span class="line">5.</span><br></pre></td></tr></table></figure>

<p>String不变性的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%B1%82%E7%B4%A0%E6%95%B0%E5%92%8C%E3%80%81%E5%88%A4%E6%96%AD%E5%80%8D%E6%95%B0/" rel="prev" title="嵌入式——汇编代码实现求素数和、判断倍数">
      <i class="fa fa-chevron-left"></i> 嵌入式——汇编代码实现求素数和、判断倍数
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/09/%E5%AE%89%E5%8D%93%E2%80%94%E2%80%94%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%E3%80%81%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8/" rel="next" title="《第一行代码——安卓》学习(二）">
      《第一行代码——安卓》学习(二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MTEzMC8yNzYxMQ"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="黄勇"
      src="/images/me_inhuda.JPG">
  <p class="site-author-name" itemprop="name">黄勇</p>
  <div class="site-description" itemprop="description">放他三千裘马去，不寄俗生。唯贪我三枕黄粱梦。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ysupreme" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ysupreme" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hy1474705581@gmail.com" title="E-Mail → mailto:hy1474705581@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Jerry75817970" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Jerry75817970" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄勇</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">55k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">50 分钟</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

  <script type="text/javascript" src="/js/cursor/firework.js"></script>
</body>
</html>
